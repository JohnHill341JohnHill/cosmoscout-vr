////////////////////////////////////////////////////////////////////////////////////////////////////
//                               This file is part of CosmoScout VR                               //
////////////////////////////////////////////////////////////////////////////////////////////////////

// SPDX-FileCopyrightText: German Aerospace Center (DLR) <cosmoscout@dlr.de>
// SPDX-License-Identifier: MIT

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D uGlareMipMap;
layout(rgba32f, binding = 2) writeonly uniform image2D uOutGlare;

// 4x4 bicubic filter using 4 bilinear texture lookups
// See GPU Gems 2: "Fast Third-Order Texture Filtering", Sigg & Hadwiger:
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter20.html




// w0, w1, w2, and w3 are the four cubic B-spline basis functions
float w0(float a) {
  return (1.0 / 6.0) * (a * (a * (-a + 3.0) - 3.0) + 1.0);
}

float w1(float a) {
  return (1.0 / 6.0) * (a * a * (3.0 * a - 6.0) + 4.0);
}

float w2(float a) {
  return (1.0 / 6.0) * (a * (a * (-3.0 * a + 3.0) + 3.0) + 1.0);
}

float w3(float a) {
  return (1.0 / 6.0) * (a * a * a);
}

// g0 and g1 are the two amplitude functions
float g0(float a) {
  return w0(a) + w1(a);
}

float g1(float a) {
  return w2(a) + w3(a);
}

// h0 and h1 are the two offset functions
float h0(float a) {
  return -1.0 + w1(a) / (w0(a) + w1(a));
}

float h1(float a) {
  return 1.0 + w3(a) / (w2(a) + w3(a));
}

vec3 cubic_filter(float x, vec3 c0, vec3 c1, vec3 c2, vec3 c3) {
    vec3 result = c0 * w0(x);
    result += c1 * w1(x);
    result += c2 * w2(x);
    result += c3 * w3(x);

    return result;
}


const int NUM_PADDING_CELLS_OFFSET = 1;
const int NUM_PADDING_CELLS_IN_TOTAL = 3;
const int NUM_SHARED_MEMORY_CELLS_ONE_D = 16+NUM_PADDING_CELLS_IN_TOTAL;
shared vec3 sharedGlareSamples[NUM_SHARED_MEMORY_CELLS_ONE_D][NUM_SHARED_MEMORY_CELLS_ONE_D];
const int totalNumSharedSamples = NUM_SHARED_MEMORY_CELLS_ONE_D*NUM_SHARED_MEMORY_CELLS_ONE_D;
const int totalNumThreadsInWorkgroup = 16 * 16;


vec3 texture2D_exact_bicubic_with_shared_memory(sampler2D tex, vec2 uv, int p_lod) {
  float lod        = float(p_lod);
  vec2  tex_size   = textureSize(uGlareMipMap, p_lod);
  uv               = uv * tex_size + 0.5;
  vec2 iuv         = floor(uv);
  ivec2 iuv_as_int = ivec2(uv - 1.0);
  vec2 fuv         = fract(uv);
  


  ivec2 globalWorkgroupStartOffset = ivec2(gl_WorkGroupID.xy * (gl_WorkGroupSize.xy) ) ;//  * (tex_size / textureSize(uGlareMipMap, 0)) );
  


  barrier();

  int total_num_cells_to_sample_per_level = (( int(gl_WorkGroupSize.x) / (1 << p_lod)) +  NUM_PADDING_CELLS_IN_TOTAL) *
                                            (( int(gl_WorkGroupSize.y) / (1 << p_lod)) +  NUM_PADDING_CELLS_IN_TOTAL);

  for(int flatGlareSampleWriteIndex = int(gl_LocalInvocationIndex);
  flatGlareSampleWriteIndex < totalNumSharedSamples; 
  flatGlareSampleWriteIndex += total_num_cells_to_sample_per_level) {

    ivec2 unflattenedGlareSampleWriteIndex = 
    ivec2(flatGlareSampleWriteIndex % NUM_SHARED_MEMORY_CELLS_ONE_D,
          flatGlareSampleWriteIndex / NUM_SHARED_MEMORY_CELLS_ONE_D);

    //calculate the offset of the shared sample array with respect to the threads local position
    ivec2 globalCellID = max(ivec2(0),(unflattenedGlareSampleWriteIndex + globalWorkgroupStartOffset) - NUM_PADDING_CELLS_OFFSET);

    vec2 vTexcoords  = (globalCellID + vec2(0.5)) / textureSize(uGlareMipMap, 0);

    vTexcoords       = vTexcoords * tex_size + 0.5;
    ivec2 iuv_as_int = ivec2(vTexcoords - 1.0);
    sharedGlareSamples[unflattenedGlareSampleWriteIndex.x][unflattenedGlareSampleWriteIndex.y]
      = texelFetch(uGlareMipMap, iuv_as_int, p_lod).rgb;

  
  }

  barrier();

  ivec2 shared_memory_sampling_base_offset = (ivec2(gl_LocalInvocationID.xy)) + NUM_PADDING_CELLS_OFFSET;

  return cubic_filter(
    fuv.y, cubic_filter(
            fuv.x, sharedGlareSamples[shared_memory_sampling_base_offset.x - 1][shared_memory_sampling_base_offset.y - 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x    ][shared_memory_sampling_base_offset.y - 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 1][shared_memory_sampling_base_offset.y - 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 2][shared_memory_sampling_base_offset.y - 1]
            ),
            cubic_filter(
            fuv.x, sharedGlareSamples[shared_memory_sampling_base_offset.x - 1][shared_memory_sampling_base_offset.y    ],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x    ][shared_memory_sampling_base_offset.y    ],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 1][shared_memory_sampling_base_offset.y    ],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 2][shared_memory_sampling_base_offset.y    ]
            ),
            cubic_filter(
            fuv.x, sharedGlareSamples[shared_memory_sampling_base_offset.x - 1][shared_memory_sampling_base_offset.y + 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x    ][shared_memory_sampling_base_offset.y + 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 1][shared_memory_sampling_base_offset.y + 1],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 2][shared_memory_sampling_base_offset.y + 1]
            ),
            cubic_filter(
            fuv.x, sharedGlareSamples[shared_memory_sampling_base_offset.x - 1][shared_memory_sampling_base_offset.y + 2],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x    ][shared_memory_sampling_base_offset.y + 2],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 1][shared_memory_sampling_base_offset.y + 2],
                   sharedGlareSamples[shared_memory_sampling_base_offset.x + 2][shared_memory_sampling_base_offset.y + 2]
            )
  );
}

vec3 texture2D_exact_bicubic(sampler2D tex, vec2 uv, int p_lod) {
  float lod        = float(p_lod);
  vec2  tex_size   = textureSize(uGlareMipMap, p_lod);
  uv               = uv * tex_size - 0.5;
  vec2 iuv         = floor(uv);
  ivec2 iuv_as_int = ivec2(uv);
  vec2 fuv         = fract(uv);
  
  return cubic_filter(
    fuv.y, cubic_filter(
            fuv.x, texelFetch(uGlareMipMap, iuv_as_int + ivec2(-1, -1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 0, -1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 1, -1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 2, -1), p_lod).rgb
            ),
            cubic_filter(
            fuv.x, texelFetch(uGlareMipMap, iuv_as_int + ivec2(-1, 0), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 0, 0), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 1, 0), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 2, 0), p_lod).rgb
            ),
            cubic_filter(
            fuv.x, texelFetch(uGlareMipMap, iuv_as_int + ivec2(-1, 1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 0, 1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 1, 1), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 2, 1), p_lod).rgb
            ),
            cubic_filter(
            fuv.x, texelFetch(uGlareMipMap, iuv_as_int + ivec2(-1, 2), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 0, 2), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 1, 2), p_lod).rgb,
                   texelFetch(uGlareMipMap, iuv_as_int + ivec2( 2, 2), p_lod).rgb
            )
        
  );
}

vec3 texture2D_fast_bicubic(sampler2D tex, vec2 uv, int p_lod) {
  float lod        = float(p_lod);
  vec2  tex_size   = textureSize(uGlareMipMap, p_lod);
  vec2  pixel_size = 1.0 / tex_size;
  uv               = uv * tex_size + 0.5;
  vec2 iuv         = floor(uv);
  vec2 fuv         = fract(uv);

  float g0x = g0(fuv.x);
  float g1x = g1(fuv.x);
  float h0x = h0(fuv.x);
  float h1x = h1(fuv.x);
  float h0y = h0(fuv.y);
  float h1y = h1(fuv.y);

  vec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * pixel_size;
  vec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * pixel_size;
  vec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * pixel_size;
  vec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * pixel_size;

  return (g0(fuv.y) * (g0x * textureLod(tex, p0, lod).rgb + g1x * textureLod(tex, p1, lod).rgb)) +
         (g1(fuv.y) * (g0x * textureLod(tex, p2, lod).rgb + g1x * textureLod(tex, p3, lod).rgb));
}

void main() {

  ivec2 pixelPos   = ivec2(gl_GlobalInvocationID.xy);
  ivec2 outputSize = imageSize(uOutGlare);

  // Discard any threads outside the output layer.
  if (pixelPos.x >= outputSize.x || pixelPos.y >= outputSize.y) {
    return;
  }

  vec3  glare     = vec3(0);
  float maxLevels = textureQueryLevels(uGlareMipMap);

  float totalWeight = 0;

  vec2 vTexcoords = (pixelPos + vec2(0.5)) / textureSize(uGlareMipMap, 0);

  // Each level contains a successively more blurred version of the scene. We have to
  // accumulate them with an exponentially decreasing weight to get a proper glare distribution.
  for (int i = 0; i < maxLevels; ++i) {
    float weight = 1.0 / (1 << i);
#ifdef BICUBIC_GLARE_FILTER

    //#define USE_EXACT_PATH_WITHOUT_SHARED_MEMORY
    //#define USE_EXACT_PATH_WITH_SHARED_MEMORY
    #define USE_APPROXIMATE_FAST_PATH

    #ifdef USE_APPROXIMATE_FAST_PATH
          glare += texture2D_fast_bicubic(uGlareMipMap, vTexcoords, i) * weight;
    #else

    #ifdef USE_EXACT_PATH_WITHOUT_SHARED_MEMORY
          glare += texture2D_exact_bicubic(uGlareMipMap, vTexcoords, i) * weight;
    #else
          glare += texture2D_exact_bicubic_with_shared_memory(uGlareMipMap, vTexcoords, i) * weight;
    #endif

    #endif

#else
    glare += textureLod(uGlareMipMap, vTexcoords, float(i)).rgb * weight;
#endif
    totalWeight += weight;
  }

  vec3 final_glare_value = glare / totalWeight;

  // vec3 sampled_glare_base_level_values = texelFetch(uGlareMipMap, pixelPos, 0).rgb;
  //  Finally store the glare value in the output layer of the glare mipmap.
  imageStore(uOutGlare, pixelPos, vec4(final_glare_value, 0.0));
}