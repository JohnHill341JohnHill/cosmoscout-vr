////////////////////////////////////////////////////////////////////////////////////////////////////
//                               This file is part of CosmoScout VR                               //
//      and may be used under the terms of the MIT license. See the LICENSE file for details.     //
//                        Copyright: (c) 2019 German Aerospace Center (DLR)                       //
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "../../../src/cs-core/GraphicsEngine.hpp"
#include "../../../src/cs-graphics/SetupGLNode.hpp"
#include "../../../src/cs-utils/TestImageCompare.hpp"
#include "../../../src/cs-utils/doctest.hpp"
#include "../../../src/cs-utils/utils.hpp"
#include "../src/AtmosphereRenderer.hpp"

// Graphical tests rely on Xvfb and image magick and therefore they are only available on Linux
#ifdef __linux__

#include <VistaKernel/GraphicsManager/VistaGeometryFactory.h>
#include <VistaKernel/GraphicsManager/VistaOpenGLNode.h>
#include <VistaKernel/GraphicsManager/VistaSceneGraph.h>
#include <VistaKernel/GraphicsManager/VistaTransformNode.h>
#include <VistaKernel/VistaSystem.h>
#include <VistaKernelOpenSGExt/VistaOpenSGMaterialTools.h>
#include <VistaTools/VistaRandomNumberGenerator.h>

namespace csp::atmospheres {

TEST_CASE("[graphical] csp::atmospheres::Atmosphere") {

  const float PLANET_RADIUS(10.F);

  auto disableCulling = [](VistaGeometry* geom) {
    VistaRenderingAttributes attribs;
    geom->GetRenderingAttributes(attribs);
    attribs.culling = VistaRenderingAttributes::raCulling::CULL_FRONT;
    geom->SetRenderingAttributes(attribs);
  };

  // The TestImageCompare initializes a VistaSystem for us. Once it's doComparison method gets
  // called, a single frame will be rendered, caputered with imagemagick and compared to a reference
  // image (using imagemagick's compare tool).
  cs::utils::TestImageCompare compare("csp-atmospheres-Atmosphere-01", 1);

  VistaSceneGraph*     pSG = GetVistaSystem()->GetGraphicsManager()->GetSceneGraph();
  VistaGeometryFactory oGeometryFactory(pSG);

  // Make sure that everything is set up to use the reverse infinite projection.
  auto* setupGLNode = pSG->NewOpenGLNode(pSG->GetRoot(), new cs::graphics::SetupGLNode());
  VistaOpenSGMaterialTools::SetSortKeyOnSubtree(
      setupGLNode, static_cast<int>(cs::utils::DrawOrder::eSetupOpenGL));

  // Create a "planet".
  VistaGeometry* pPlanet = oGeometryFactory.CreateSphere(1, 300, VistaColor::GRAY);
  disableCulling(pPlanet);

  VistaTransformNode* pPlanetTransform = pSG->NewTransformNode(pSG->GetRoot());
  pPlanetTransform->SetScale(PLANET_RADIUS, PLANET_RADIUS, PLANET_RADIUS);
  pPlanetTransform->Translate(0, 0, -2 * PLANET_RADIUS);
  pSG->NewGeomNode(pPlanetTransform, pPlanet);

  // Create some "mountains".
  VistaRandomNumberGenerator* pRnd = VistaRandomNumberGenerator::GetStandardRNG();
  pRnd->SetSeed(0);

  for (int i(0); i < 1000; ++i) {
    VistaGeometry* pMountain = oGeometryFactory.CreateSphere(1, 50, VistaColor::GRAY);
    disableCulling(pMountain);

    VistaTransformNode* pTransformNode = pSG->NewTransformNode(pPlanetTransform);
    pTransformNode->SetScale(1, 1, 1);

    float size  = pRnd->GenerateFloat(0.2F, 0.22F);
    float phi   = pRnd->GenerateFloat(0.0F, 2 * Vista::Pi);
    float theta = std::acos(pRnd->GenerateFloat(-1.F, 1.F));
    float x     = std::sin(theta) * std::cos(phi) * 0.8;
    float y     = std::sin(theta) * std::sin(phi) * 0.8;
    float z     = std::cos(theta) * 0.8;

    pTransformNode->Scale(size, size, size);
    pTransformNode->Translate(x, y, z);
    pSG->NewGeomNode(pTransformNode, pMountain);
  }

  // Create the atmosphere.
  auto settings           = std::make_shared<Plugin::Settings>();
  settings->mEnableClouds = false;
  AtmosphereRenderer atmosphere(settings, nullptr);

  atmosphere.setSun(glm::vec3(1, 0, 0), 15.0);
  atmosphere.setAtmosphereHeight(70.0 / 3460.0);
  atmosphere.setMieHeight(5.0 / 3460.0);
  atmosphere.setMieScattering(
      glm::vec3(21.0e-6F * 3460000.F, 21.0e-6F * 3460000.F, 21.0e-6F * 3460000.F));
  atmosphere.setMieAnisotropy(0.76);
  atmosphere.setRayleighHeight(11.0 / 3460.0);
  atmosphere.setRayleighScattering(
      glm::vec3(20.0e-6F * 3460000.F, 13.5e-6F * 3460000.F, 5.75e-6F * 3460000.F));
  atmosphere.setRayleighAnisotropy(0);

  auto* atmosphereNode = pSG->NewOpenGLNode(pPlanetTransform, &atmosphere);

  VistaOpenSGMaterialTools::SetSortKeyOnSubtree(
      pPlanetTransform, static_cast<int>(cs::utils::DrawOrder::ePlanets));
  VistaOpenSGMaterialTools::SetSortKeyOnSubtree(
      atmosphereNode, static_cast<int>(cs::utils::DrawOrder::eAtmospheres));

  // Do the image comparision, allowing for a slight maximum per-pixel difference of 2%. There is
  // currently a maximum error of around 1.2% between the images generated by clang and gcc.
  // Therefore this threshold has been choosen.
  CHECK_LT(compare.doComparison(), 2.F);
}
} // namespace csp::atmospheres

#endif